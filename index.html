<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nullwood Black Tree Pattern Generator v12.1 (Mobile Fix)</title>
    <style>
        :root {
            --bg-main: #e0e0e0;
            --panel-bg: rgba(255, 255, 255, 0.65); 
            --section-bg: rgba(255, 255, 255, 0.9);
            --text-color: #333;
            --accent: #555;
            --gold: #D4AF37;
            --border: rgba(0,0,0,0.1);
        }

        body {
            margin: 0;
            background-color: var(--bg-main);
            background-repeat: repeat;
            background-position: center;
            background-image: linear-gradient(rgba(240,240,240,0.6), rgba(240,240,240,0.6));
            
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            color: var(--text-color);
            padding: 40px 20px;
            box-sizing: border-box;
        }

        .main-panel {
            background: var(--panel-bg);
            border: 1px solid rgba(255,255,255,0.4);
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 30px 70px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            width: 100%;
            max-width: 580px;
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
        }

        header {
            width: 100%;
            text-align: center;
            margin-bottom: 5px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }

        h1 {
            margin: 0 0 15px 0;
            font-weight: 300;
            letter-spacing: 4px;
            font-size: 22px;
            text-transform: uppercase;
            color: #444;
            text-shadow: 0 1px 2px rgba(255,255,255,0.8);
        }

        .description {
            font-size: 12px; line-height: 1.5; color: #555; text-align: justify;
            text-align-last: center; font-weight: 400; margin-bottom: 20px; padding: 0 10px;
        }
        .description strong { color: #333; font-weight: 600; }

        .support-links-row { display: flex; gap: 10px; width: 100%; justify-content: center; }
        .support-link { flex: 1; text-decoration: none; }
        .support-btn {
            width: 100%; padding: 10px; background: transparent; border: 1px solid #999; 
            color: #555; font-size: 10px; font-weight: bold; text-transform: uppercase;
            cursor: pointer; border-radius: 4px; transition: all 0.2s; display: flex;
            justify-content: center; align-items: center; gap: 6px;
        }
        .support-btn:hover { background: #333; color: #fff; border-color: #333; }

        .ui-section {
            background: var(--section-bg); width: 100%; padding: 20px; border-radius: 8px;
            box-sizing: border-box; border: 1px solid rgba(0,0,0,0.05); display: flex;
            flex-direction: column; align-items: center; gap: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.02);
        }

        #preview-container {
            width: 100%; aspect-ratio: 1 / 1; background: #fff; border: 1px solid #eee;
            overflow: hidden; display: flex; justify-content: center; align-items: center;
            position: relative; border-radius: 4px;
        }
        #preview-container svg { display: block; width: 100%; height: 100%; }
        #loading-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.75); display: none; justify-content: center;
            align-items: center; flex-direction: column; z-index: 100;
        }
        #loading-text { font-size: 14px; font-weight: bold; color: #fff; margin-bottom: 15px; letter-spacing: 2px; }
        #progress-bar { width: 50%; height: 2px; background: #555; border-radius: 2px; overflow: hidden; }
        #progress-fill { height: 100%; width: 0%; background: #fff; transition: width 0.1s linear; }
        #style-label { font-size: 11px; color: #888; font-style: italic; margin-top: -5px; }

        .mode-toggle-row { display: flex; gap: 10px; width: 100%; margin-bottom: 10px; }
        .mode-btn {
            flex: 1; padding: 10px; background: #f0f0f0; border: 1px solid #ccc;
            color: #555; font-size: 11px; font-weight: bold; text-transform: uppercase;
            cursor: pointer; border-radius: 4px; transition: all 0.2s;
        }
        .mode-btn.active { background: #333; color: #fff; border-color: #333; }

        .instruction-text {
            font-size: 10px; color: #999; text-transform: uppercase;
            letter-spacing: 1px; margin-bottom: 5px; text-align: center; font-weight: 600;
        }
        
        .controls-row {
            display: flex; justify-content: space-between; width: 100%; gap: 20px; align-items: center;
        }
        
        .slider-group {
            display: flex; flex-direction: column; flex: 1; gap: 8px;
            padding: 0 8px; box-sizing: border-box; 
        }
        .slider-header {
            display: flex; justify-content: space-between; font-size: 11px; font-weight: bold; color: #555; text-transform: uppercase;
            margin: 0 -8px; 
        }

        .range-container {
            position: relative; width: 100%; height: 20px; display: flex; align-items: center;
        }

        .slider-track-bg {
            position: absolute; top: 50%; left: 0; width: 100%; height: 2px;
            background-color: rgba(0,0,0,0.1); border-radius: 2px; transform: translateY(-50%);
            pointer-events: none;
            background-image: 
                radial-gradient(circle, #999 2px, transparent 2.5px),
                radial-gradient(circle, #999 2px, transparent 2.5px),
                radial-gradient(circle, #999 2px, transparent 2.5px),
                radial-gradient(circle, #999 2px, transparent 2.5px),
                radial-gradient(circle, #999 2px, transparent 2.5px);
            background-size: 6px 6px; background-repeat: no-repeat;
            background-position: 
                7px center, 
                calc(25% + 3.5px) center, 
                center center, 
                calc(75% - 3.5px) center, 
                calc(100% - 7px) center;
        }

        input[type=range] {
            width: 100%; margin: 0; -webkit-appearance: none; background: transparent;
            position: relative; z-index: 2; cursor: pointer;
        }
        input[type=range]::-webkit-slider-runnable-track { background: transparent; height: 14px; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; 
            background: #333; margin-top: 0; box-shadow: 0 0 0 2px #fff;
        }

        #genBtn {
            width: 100%; padding: 15px; background: #222; color: #fff; border: none;
            font-size: 13px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px;
            cursor: pointer; border-radius: 4px; transition: background 0.2s; margin-top: 10px;
        }
        #genBtn:hover { background: #444; }
        #genBtn:disabled { background: #999; cursor: wait; }

        .instruction-text-save {
             font-size: 10px; color: #999; text-transform: uppercase; letter-spacing: 1px; font-weight: 600;
        }
        .btn-row { display: flex; gap: 10px; width: 100%; }
        .btn-row button {
            flex: 1; padding: 12px; background: #f0f0f0; border: 1px solid #ccc;
            color: #333; font-size: 11px; font-weight: bold; text-transform: uppercase;
            cursor: pointer; border-radius: 4px; transition: all 0.2s;
        }
        .btn-row button:hover { background: #e0e0e0; border-color: #999; }

        footer { margin-top: auto; padding-top: 40px; font-size: 10px; color: #888; letter-spacing: 1px; }
    </style>
</head>
<body>

    <div class="main-panel">
        
        <header>
            <h1>Nullwood Black Tree Pattern Generator</h1>
            <p class="description">
                This generative art tool is a component of the <strong>Nullwood Project</strong> by artist <strong>SHHAN</strong>. 
                It visualizes the microscopic essence and energy flow of the 'Black Trees' inhabiting the Nullwood universe. 
                Patterns created here can be exported as high-resolution PNGs and vector SVGs.
            </p>
            
            <div class="support-links-row">
                <a href="https://www.paypal.com/ncp/payment/FZ6EU86QNH6E8" target="_blank" class="support-link">
                    <button class="support-btn">â˜• Buy SHHAN a Coffee</button>
                </a>
                <a href="https://linktr.ee/shhan1211" target="_blank" class="support-link">
                    <button class="support-btn">ðŸŒ² SHHAN Linktree</button>
                </a>
            </div>
        </header>

        <div class="ui-section">
            <div id="preview-container">
                <div id="loading-overlay">
                    <div id="loading-text">GENERATING... 0%</div>
                    <div id="progress-bar"><div id="progress-fill"></div></div>
                </div>
            </div>
            <div id="style-label">Style: Initializing...</div>
        </div>

        <div class="ui-section">
            <div class="mode-toggle-row">
                <button id="btn-mono" class="mode-btn active">Monochrome</button>
                <button id="btn-color" class="mode-btn">Hokusai Color</button>
            </div>

            <div class="instruction-text">Select mode, set dimensions, and click GENERATE</div>
            
            <div class="controls-row">
                <div class="slider-group">
                    <div class="slider-header"><span>Width (X)</span><span id="valX">x1</span></div>
                    <div class="range-container">
                        <div class="slider-track-bg"></div>
                        <input type="range" id="scaleX" min="1" max="5" value="1" step="1">
                    </div>
                </div>

                <div class="slider-group">
                    <div class="slider-header"><span>Height (Y)</span><span id="valY">x1</span></div>
                    <div class="range-container">
                        <div class="slider-track-bg"></div>
                        <input type="range" id="scaleY" min="1" max="5" value="1" step="1">
                    </div>
                </div>
            </div>

            <button id="genBtn">Generate New Pattern</button>
        </div>

        <div class="ui-section">
            <div class="instruction-text-save">Export high-resolution files</div>
            <div class="btn-row">
                <button id="savePngBtn">Save as PNG</button>
                <button id="saveSvgBtn">Save as SVG</button>
            </div>
        </div>

    </div>

    <footer>Copyright Â© 2026 SHHAN. All Rights Reserved.</footer>

<script>
    const previewContainer = document.getElementById('preview-container');
    const loadingOverlay = document.getElementById('loading-overlay');
    const loadingText = document.getElementById('loading-text');
    const progressFill = document.getElementById('progress-fill');
    const styleLabel = document.getElementById('style-label');
    const scaleXInput = document.getElementById('scaleX');
    const scaleYInput = document.getElementById('scaleY');
    const valXDisplay = document.getElementById('valX');
    const valYDisplay = document.getElementById('valY');
    const genBtn = document.getElementById('genBtn');
    const savePngBtn = document.getElementById('savePngBtn');
    const saveSvgBtn = document.getElementById('saveSvgBtn');
    const btnMono = document.getElementById('btn-mono');
    const btnColor = document.getElementById('btn-color');

    const BASE_SIZE = 1000;
    let currentSVGString = '';
    let seed = Math.random();
    let isGenerating = false;
    let isColorMode = false;

    const HOKUSAI_PALETTES = [
        { bg: '#eaddca', layers: ['#1d2951', '#3b5b91', '#5d8aa8', '#b0c4de'] },
        { bg: '#fbe0c6', layers: ['#5e2c0b', '#8b4513', '#2f4f4f', '#c5a059'] },
        { bg: '#d0e0f0', layers: ['#001f3f', '#0064b0', '#008b8b', '#5f9ea0'] }
    ];
    let currentColorPalette = null;

    const monoTheme = {
        bg: '#f4f4f4', fill: '#1a1a1a', 
        layers: [
            { threshold: 0.10, r: 0.6, opacity: 0.25 }, 
            { threshold: 0.35, r: 1.0, opacity: 0.45 }, 
            { threshold: 0.55, r: 1.5, opacity: 0.65 }, 
            { threshold: 0.75, r: 2.2, opacity: 0.85 }  
        ]
    };

    const Permutation = new Uint8Array([151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,45,106,128,243,176,236,93,114,195,215,199,78,150,254,29,72,222,4,121,156,204,115,127,205,254,206,127,29,233,9,128,226]);
    const p = new Uint8Array(512);
    const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
    for(let i=0; i<512; i++) p[i] = Permutation[i & 255];
    function dot(g, x, y, z) { return g[0]*x + g[1]*y + g[2]*z; }
    function noise3D(xin, yin, zin) {
        let n0, n1, n2, n3; const F3 = 1.0/3.0; const G3 = 1.0/6.0;
        let s = (xin+yin+zin)*F3; let i = Math.floor(xin+s); let j = Math.floor(yin+s); let k = Math.floor(zin+s);
        let t = (i+j+k)*G3; let X0 = i-t; let Y0 = j-t; let Z0 = k-t; let x0 = xin-X0; let y0 = yin-Y0; let z0 = zin-Z0;
        let i1, j1, k1; let i2, j2, k2; if(x0>=y0) { if(y0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } } else { if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } }
        let x1 = x0 - i1 + G3; let y1 = y0 - j1 + G3; let z1 = z0 - k1 + G3; let x2 = x0 - i2 + 2.0*G3; let y2 = y0 - j2 + 2.0*G3; let z2 = z0 - k2 + 2.0*G3; let x3 = x0 - 1.0 + 3.0*G3; let y3 = y0 - 1.0 + 3.0*G3; let z3 = z0 - 1.0 + 3.0*G3;
        let ii = i & 255; let jj = j & 255; let kk = k & 255;
        let gi0 = p[ii+p[jj+p[kk]]] % 12; let gi1 = p[ii+i1+p[jj+j1+p[kk+k1]]] % 12; let gi2 = p[ii+i2+p[jj+j2+p[kk+k2]]] % 12; let gi3 = p[ii+1+p[jj+1+p[kk+1]]] % 12;
        let t0 = 0.6 - x0*x0 - y0*y0 - z0*z0; if(t0<0) n0 = 0.0; else { t0 *= t0; n0 = t0 * t0 * dot(grad3[gi0], x0, y0, z0); }
        let t1 = 0.6 - x1*x1 - y1*y1 - z1*z1; if(t1<0) n1 = 0.0; else { t1 *= t1; n1 = t1 * t1 * dot(grad3[gi1], x1, y1, z1); }
        let t2 = 0.6 - x2*x2 - y2*y2 - z2*z2; if(t2<0) n2 = 0.0; else { t2 *= t2; n2 = t2 * t2 * dot(grad3[gi2], x2, y2, z2); }
        let t3 = 0.6 - x3*x3 - y3*y3 - z3*z3; if(t3<0) n3 = 0.0; else { t3 *= t3; n3 = t3 * t3 * dot(grad3[gi3], x3, y3, z3); }
        return 32.0*(n0 + n1 + n2 + n3);
    }
    function getTileableNoise(x, y, scaleX, scaleY, seedVal, totalWidth, totalHeight) {
        let s = x / totalWidth; let t = y / totalHeight;
        let nx = Math.cos(s * Math.PI * 2) * scaleX; 
        let ny = Math.sin(s * Math.PI * 2) * scaleY;
        let nz = Math.cos(t * Math.PI * 2) * scaleX; 
        let nw = Math.sin(t * Math.PI * 2) * scaleY;
        return (noise3D(nx + seedVal, ny + seedVal, nz) + noise3D(nx + seedVal, ny + seedVal, nw + 100)) / 2; 
    }

    async function generateCircleDataAsync(targetWidth, targetHeight) {
        let circles = []; monoTheme.layers.forEach(() => circles.push([]));
        const totalBaseCount = 120000; const areaMultiplier = (targetWidth * targetHeight) / (BASE_SIZE * BASE_SIZE);
        const totalCount = Math.round(totalBaseCount * areaMultiplier);
        const f = (n) => n.toFixed(1);
        const chunkSize = 2500; let processed = 0;
        return new Promise((resolve) => {
            function processChunk() {
                const end = Math.min(processed + chunkSize, totalCount);
                for(let i = processed; i < end; i++) {
                    let x = Math.random() * targetWidth; let y = Math.random() * targetHeight;
                    let flowN = getTileableNoise(x, y, currentStyle.flowScaleX, currentStyle.flowScaleY, seed, targetWidth, targetHeight); 
                    let angle = (Math.PI / 2) + (flowN * Math.PI); 
                    let denseN = getTileableNoise(x, y, currentStyle.densityScale, currentStyle.densityScale, seed + 50, targetWidth, targetHeight);
                    let density = (denseN + 1) / 2;
                    let flowPush = (Math.random() - 0.5) * currentStyle.jitter * 2; 
                    let finalX = x + Math.cos(angle) * flowPush; let finalY = y + Math.sin(angle) * flowPush;
                    finalX = (finalX + targetWidth) % targetWidth; finalY = (finalY + targetHeight) % targetHeight;
                    for(let layerIdx = monoTheme.layers.length - 1; layerIdx >= 0; layerIdx--) {
                        const config = monoTheme.layers[layerIdx];
                        if (density > config.threshold) {
                            let r = config.r * (0.8 + Math.random() * 0.4);
                            let circleSvg = `<circle cx="${f(finalX)}" cy="${f(finalY)}" r="${f(r)}" />`;
                            circles[layerIdx].push(circleSvg);
                            if (finalX < r) circles[layerIdx].push(`<circle cx="${f(finalX + targetWidth)}" cy="${f(finalY)}" r="${f(r)}" />`);
                            if (finalX > targetWidth - r) circles[layerIdx].push(`<circle cx="${f(finalX - targetWidth)}" cy="${f(finalY)}" r="${f(r)}" />`);
                            if (finalY < r) circles[layerIdx].push(`<circle cx="${f(finalX)}" cy="${f(finalY + targetHeight)}" r="${f(r)}" />`);
                            if (finalY > targetHeight - r) circles[layerIdx].push(`<circle cx="${f(finalX)}" cy="${f(finalY - targetHeight)}" r="${f(r)}" />`);
                            break; 
                        }
                    }
                    if (density <= monoTheme.layers[0].threshold) {
                         let config = monoTheme.layers[0]; let r = config.r * (0.7 + Math.random() * 0.3);
                         circles[0].push(`<circle cx="${f(finalX)}" cy="${f(finalY)}" r="${f(r)}" />`);
                    }
                }
                processed = end;
                const progress = Math.floor((processed / totalCount) * 100);
                loadingText.textContent = `GENERATING... ${progress}%`;
                progressFill.style.width = `${progress}%`;
                if (processed < totalCount) { setTimeout(processChunk, 0); } else { resolve(circles); }
            }
            processChunk();
        });
    }

    function buildSvgString(w, h, circlesData, isBg) {
        const currentBg = isColorMode && currentColorPalette ? currentColorPalette.bg : monoTheme.bg;
        const baseFill = isColorMode ? 'none' : monoTheme.fill;
        let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" style="background-color:${currentBg}">`;
        circlesData.forEach((circles, i) => {
            if(circles.length === 0) return;
            const config = monoTheme.layers[i];
            let layerFill = baseFill;
            let layerOpacity = isBg ? config.opacity * 0.6 : config.opacity;
            if (isColorMode && currentColorPalette) {
                layerFill = currentColorPalette.layers[i];
                layerOpacity = isBg ? 0.7 : 0.9;
            }
            svgContent += `<g fill="${layerFill}" opacity="${layerOpacity}">${circles.join('')}</g>`;
        });
        svgContent += `</svg>`;
        return svgContent;
    }

    function updateValDisplay() {
        valXDisplay.textContent = `x${scaleXInput.value}`;
        valYDisplay.textContent = `x${scaleYInput.value}`;
    }

    function randomizeStyle() {
        const styles = [
            { name: "Straight Grain", flowScaleX: 0.5, flowScaleY: 3.0, densityScale: 1.0, jitter: 3.0 },
            { name: "Wavy Grain", flowScaleX: 1.5, flowScaleY: 2.5, densityScale: 1.5, jitter: 5.0 },
            { name: "Knots & Burls", flowScaleX: 2.5, flowScaleY: 1.5, densityScale: 2.5, jitter: 8.0 },
            { name: "Water Flow", flowScaleX: 1.0, flowScaleY: 1.0, densityScale: 1.2, jitter: 4.0 },
            { name: "Chaotic", flowScaleX: 3.0, flowScaleY: 3.0, densityScale: 2.0, jitter: 10.0 }
        ];
        let baseStyle = styles[Math.floor(Math.random() * styles.length)];
        currentStyle = {
            name: baseStyle.name,
            flowScaleX: baseStyle.flowScaleX * (0.8 + Math.random()*0.4),
            flowScaleY: baseStyle.flowScaleY * (0.8 + Math.random()*0.4),
            densityScale: baseStyle.densityScale * (0.8 + Math.random()*0.4),
            jitter: baseStyle.jitter * (0.8 + Math.random()*0.4)
        };
        styleLabel.textContent = `Style: ${currentStyle.name} (${isColorMode ? 'Color' : 'Mono'})`;
    }

    async function generate() {
        if(isGenerating) return;
        isGenerating = true;
        genBtn.disabled = true;
        loadingOverlay.style.display = 'flex';
        loadingText.textContent = "INITIALIZING...";
        progressFill.style.width = "0%";
        
        const sx = parseInt(scaleXInput.value);
        const sy = parseInt(scaleYInput.value);
        seed = Math.random() * 1000;
        
        if (isColorMode) {
            currentColorPalette = HOKUSAI_PALETTES[Math.floor(Math.random() * HOKUSAI_PALETTES.length)];
        } else {
            currentColorPalette = null;
        }
        randomizeStyle();

        await new Promise(r => setTimeout(r, 50));
        const w = BASE_SIZE * sx;
        const h = BASE_SIZE * sy;
        const circlesData = await generateCircleDataAsync(w, h);
        currentSVGString = buildSvgString(w, h, circlesData, false);
        previewContainer.innerHTML = currentSVGString;
        previewContainer.appendChild(loadingOverlay); 
        loadingOverlay.style.display = 'none';
        
        setTimeout(async () => {
             const wasColorMode = isColorMode;
             isColorMode = false; 
             const bgData = await generateCircleDataAsync(BASE_SIZE, BASE_SIZE);
             const bgSVG = buildSvgString(BASE_SIZE, BASE_SIZE, bgData, true);
             isColorMode = wasColorMode; 

             const encodedSVG = encodeURIComponent(bgSVG);
             const dataURI = `url("data:image/svg+xml,${encodedSVG}")`;
             document.body.style.backgroundImage = `linear-gradient(rgba(240,240,240,0.85), rgba(240,240,240,0.85)), ${dataURI}`;
             isGenerating = false;
             genBtn.disabled = false;
        }, 50);
    }

    function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }
    saveSvgBtn.onclick = () => {
        if(isGenerating) return;
        const sx = scaleXInput.value;
        const sy = scaleYInput.value;
        const modeStr = isColorMode ? 'Color' : 'Mono';
        const blob = new Blob([currentSVGString], {type: 'image/svg+xml;charset=utf-8'});
        downloadBlob(blob, `Nullwood_DotTree_${currentStyle.name.split(' ')[0]}_${modeStr}_${sx}x${sy}.svg`);
    };
    
    // [Mobile Share Fix]
    savePngBtn.onclick = () => {
        if(isGenerating) return;
        const sx = scaleXInput.value;
        const sy = scaleYInput.value;
        const width = BASE_SIZE * sx;
        const height = BASE_SIZE * sy;
        const img = new Image();
        const svgBlob = new Blob([currentSVGString], {type: 'image/svg+xml;charset=utf-8'});
        const url = URL.createObjectURL(svgBlob);
        
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            const currentBg = isColorMode && currentColorPalette ? currentColorPalette.bg : monoTheme.bg;
            ctx.fillStyle = currentBg;
            ctx.fillRect(0,0,width,height);
            ctx.drawImage(img, 0, 0);
            URL.revokeObjectURL(url);
            
            const modeStr = isColorMode ? 'Color' : 'Mono';
            const fileName = `Nullwood_DotTree_${currentStyle.name.split(' ')[0]}_${modeStr}_${sx}x${sy}.png`;

            canvas.toBlob((blob) => {
                const file = new File([blob], fileName, { type: 'image/png' });
                
                if (navigator.canShare && navigator.canShare({ files: [file] })) {
                    navigator.share({
                        files: [file],
                        title: 'Nullwood Pattern',
                        text: 'Generated by Nullwood Black Tree Generator'
                    })
                    .catch((error) => console.log('Sharing failed', error));
                } else {
                    downloadBlob(blob, fileName);
                }
            }, 'image/png');
        };
        img.src = url;
    };

    btnMono.onclick = () => {
        if (isGenerating || !isColorMode) return;
        isColorMode = false;
        btnMono.classList.add('active');
        btnColor.classList.remove('active');
    };
    btnColor.onclick = () => {
        if (isGenerating || isColorMode) return;
        isColorMode = true;
        btnColor.classList.add('active');
        btnMono.classList.remove('active');
    };

    genBtn.onclick = generate;
    scaleXInput.oninput = updateValDisplay;
    scaleYInput.oninput = updateValDisplay;
    generate(); 
</script>
</body>
</html>
